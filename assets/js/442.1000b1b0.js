(window.webpackJsonp=window.webpackJsonp||[]).push([[442],{906:function(l,e,r){"use strict";r.r(e);var a=r(2),n=Object(a.a)({},(function(){var l=this,e=l._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[e("h2",{attrs:{id:"背景介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#背景介绍"}},[l._v("#")]),l._v(" 背景介绍")]),l._v(" "),e("blockquote",[e("p",[l._v("由于 C/C++ 不是一门内存安全的语言，所以此类问题会经常遇到。而在项目开发中，相关 bug 的定位、解决速度可能影响着项目的整个进度，因此开发者们亟需一个内存检测器来诊断、发现这类错误。实际在 ASan 出现之前，市面上就已经存在了许多内存检测器:")])]),l._v(" "),e("ul",[e("li",[e("p",[l._v("Dr.Memory 检测未初始化的内存访问、double free、use after free 等错误")])]),l._v(" "),e("li",[e("p",[l._v("Mudflap 检测指针的解引用，静态插桩")])]),l._v(" "),e("li",[e("p",[l._v("Insure++ 检测内存泄漏")])]),l._v(" "),e("li",[e("p",[l._v("Valgrind 可以检测非常多的内存错误")])]),l._v(" "),e("li",[e("p",[l._v("但各工具目前都有各自的问题:")]),l._v(" "),e("ul",[e("li",[l._v("Dr.Memory、Insure++ 和 Mudflap 虽然在运行时造成的额外损耗比较少，但是检测场景有限；")]),l._v(" "),e("li",[l._v("Valgrind 虽然能够在许多场景的检测出错误，但是它实现了自己的一套 ISA 并在其之上运行目标程序，因此它会严重拖慢目标程序的速度;")])])]),l._v(" "),e("li",[e("p",[l._v("ASan 在设计时就综合考虑了检测场景、速度的影响因素，结合了 Mudflap 的静态插桩、Valgrind 的多场景检测。ASan 由两部分组成：一个是静态插桩模块，将内存访问判断的逻辑直接插入在了二进制中，保证了检测逻辑的执行速度；另一部分则是运行时库，提供部分功能的开启、报错函数和 malloc/free/memcpy 等函数的 asan 检测版本。")])])]),l._v(" "),e("p",[l._v("kill -15 pid（默认）\n执行完该指令后，操作系统会发送一个 SIGTERM 信号给对应的程序。当程序接收到该信号后，可能会发生以下几种情况的一种：\n当前程序立刻停止；")])])}),[],!1,null,null,null);e.default=n.exports}}]);