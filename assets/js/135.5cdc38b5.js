(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{541:function(v,_,l){"use strict";l.r(_);var i=l(2),t=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"内联函数定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内联函数定义"}},[v._v("#")]),v._v(" 内联函数定义")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("inline内联函数是C++引入的机制，目的是解决使用宏定义的缺点：")]),v._v(" "),_("ul",[_("li",[v._v("无法进行强制类型检查；")]),v._v(" "),_("li",[v._v("返回值无法转换为可转换的合适类型；")]),v._v(" "),_("li",[v._v("书写不规范容易产生二义性；")]),v._v(" "),_("li",[v._v("无法使用类成员；")])])]),v._v(" "),_("li",[_("p",[v._v("区别和联系")]),v._v(" "),_("ul",[_("li",[v._v("内联函数在编译时展开，宏定义在预编译时展开；")]),v._v(" "),_("li",[v._v("内联函数在编译时可直接被嵌入到目标代码中，而宏定义在预编译时展开，仅做简单文本替换；")]),v._v(" "),_("li",[v._v("内联函数可完成类型检查、语句检查等编译功能，宏不具备；")]),v._v(" "),_("li",[v._v("宏不是函数，inline内联函数是；")]),v._v(" "),_("li",[v._v("宏定义需小心处理宏参数（主要是括号的使用），否则容易出现二义性而内联函数不会")])])]),v._v(" "),_("li",[_("p",[v._v("内联函数注意事项：")]),v._v(" "),_("ul",[_("li",[v._v("内联函数以代码膨胀（目标代码中复制多份）为代价；")]),v._v(" "),_("li",[v._v("函数体过长不宜使用内联；（C++代码也会智能判断）")]),v._v(" "),_("li",[v._v("函数体较复杂如出现循环不宜使用内联；")]),v._v(" "),_("li",[v._v("内联函数不会在cpp对应的obj文件中产生，故要求声明和定义在一起，否则会无法连接；")])])])])])}),[],!1,null,null,null);_.default=t.exports}}]);